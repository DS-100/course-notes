{"title":"Visualization I","markdown":{"yaml":{"title":"Visualization I","format":{"html":{"toc":true,"toc-depth":5,"toc-location":"right","code-fold":false,"theme":["cosmo","cerulean"],"callout-icon":false}},"jupyter":"python3"},"headingText":"Visualizations in Data 8 and Data 100 (so far)","containsRefs":false,"markdown":"\n\nIn our journey of the data science lifecycle, we have begun to explore the vast world of exploratory data analysis. More recently, we learned how to pre-process data using feature engineering and data manipulation techniques. As we work towards designing complex models, there is one key component missing in our arsenal - the ability to visualize and discern relationships in existing data.\n\nThese next two lectures will introduce you to various examples of data visualizations and their underlying theory. In doing so, we'll motivate their usefulness in real-world examples with helpful plotting libraries.\n\n\nYou've likely encountered several forms of data visualizations in your studies. You may remember two such examples from Data 8: line charts and histograms. Each of these served a unique purpose. For example, line charts displayed how numerical quantities changed over time, while histograms were useful in understanding a variable's distribution. \n\n:::: {.columns}\n\n::: {.column width=\"30%\"}\n**Line Chart**\n\n<img src=\"images/line_chart_viz.png\" alt='line_chart_viz' width='300'>\n:::\n\n::: {.column width=\"20%\"}\n<!-- empty column to create gap -->\n:::\n\n::: {.column width=\"30%\"}\n**Histogram**\n\n<img src=\"images/histogram_viz.png\" alt='histogram_viz' width='400'>\n:::\n\n::::\n\n### Goals of Visualization\n\nVisualizations are useful for a number of reasons. In Data 100, we consider two areas in particular:\n\n1. To broaden your understanding of the data\n    - Key part in exploratory data analysis\n    - Useful in investigating relationships between variables\n2. To communicate your results to others\n    - Visualization theory is especially important here\n\nOne of the most common applications of visualizations - and the one that will be covered today - is in understanding a distribution of data.\n\n### An Overview of Distributions\n\nA distribution describes the frequency of unique values in a variable. Distributions must satisfy two properties:\n\n   1. Each data point must belong to only one category.\n   2. The total frequency of all categories must sum to 100%. In other words, their total count should equal the number of values in consideration.\n   \nLet's look at a couple of examples.\n\n:::: {.columns}\n\n::: {.column width=\"30%\"}\n**Not a Valid Distribution**\n\n<img src=\"images/bad_distro.png\" alt='bad_distro' width='300'>\n:::\n\n::: {.column width=\"20%\"}\n<!-- empty column to create gap -->\n:::\n\n::: {.column width=\"30%\"}\n**Valid Distribution**\n\n<img src=\"images/good_distro.png\" alt='good_distro' width='400'>\n:::\n\n::::\n\nLeft Diagram: This is **not a valid distribution**. Individuals can belong to more than one category and the total frequency of all categories does not sum up to 100%. \n\nRight Diagram: This example satisfies the two properties of distributions, so it is a **valid distribution**.\n\n### Bar Plots\n\nAs we saw above, **bar plots** are one of the most common ways of displaying the distribution of a **qualitative** (categorical) variable. The length of a bar plot encodes the frequency of a category; the width encodes no useful information.\n\nLet's contextualize this in an example. We will use the familiar `births` dataset from Data 8 in our analysis.\n\n```{python}\n#| code-fold: true\nimport pandas as pd\n\nbirths = pd.read_csv(\"data/baby.csv\")\nbirths.head(5)\n```\n\nWe can visualize the distribution of the `Maternal Smoker` column using a bar plot. There are a few ways to do this.\n\n#### Plotting in Pandas\n\n```{python}\nbirths['Maternal Smoker'].value_counts().plot(kind = 'bar');\n```\n\nRecall that `.value_counts()` returns a Series with the total count of each unique value. We call `.plot(kind = 'bar')` on this result to visualize these counts as a bar plot.\n\nPlotting methods in `pandas` are the least preferred and not supported in Data 100, as their functionality is limited. Instead, future examples will focus on other libaries built specifically for visualizing data. The most well-known library here is `matplotlib`.\n\n#### Plotting in Matplotlib\n\n```{python}\nimport matplotlib.pyplot as plt\n\nms = births['Maternal Smoker'].value_counts()\nplt.bar(ms.index, ms)\nplt.xlabel(\"Maternal Smoker\")\nplt.ylabel(\"Count\");\n```\n\nWhile more code is required to achieve the same result, `matplotlib` is often used over `pandas` for its ability to plot more complex visualizations, some of which are discussed shortly.\n\nHowever, notice how the x-axis is a range of integers rather than the two categories, `True` and `False`. This is because `matplotlib` coerces `True` to a value of 1 and `False` to 0. Also, note how we needed to label the axes with `plt.xlabel` and `plt.ylabel` - `matplotlib` does not support automatic axis labeling. To get around these inconveniences, we can use a more effecient plotting library, `seaborn`.\n\n#### Plotting in Seaborn\n\n```{python}\nimport seaborn as sns\nsns.countplot(data = births, x = \"Maternal Smoker\");\n```\n\n`seaborn.countplot` both counts and visualizes the number of unique values in a given column. This column is specified by the `x` argument to `sns.countplot`, while the DataFrame is specified by the `data` argument.\n\nFor the vast majority of visualizations, `seaborn` is far more concise and aesthetically pleasing than `matplotlib`. However, the color scheme of this particular bar plot is abritrary - it encodes no additional information about the categories themselves. This is not always true; color may signify meaningful detail in other visualizations. We'll explore this more in-depth during the next lecture.\n\n#### Plotting in Plotly\n\n<img src=\"/visualization_1_files/plotly_viz.png\" alt='plotly_viz' width='600'>\n\n`plotly` is one of the most versatile plottling libraries and widely used in industry. However, `plotly` has various dependencies that make it difficult to support in Data 100. Therfore, we have intentionally excluded the code to generate the plot above.\n\nBy now, you'll have noticed that each of these plotting libraries have a very different syntax. As with `pandas`, we'll teach you the important methods in `matplotlib` and `seaborn`, but you'll learn more through documentation.\n\n1. [Matplotlib Documentation](https://matplotlib.org/stable/index.html)\n2. [Seaborn Documentation](https://seaborn.pydata.org/)\n\n### Histograms\n\n**Histograms** are a natural extension to bar plots; they visualize the distribution of **quantitative** (numerical) data.\n\nRevisiting our example with the `births` DataFrame, let's plot the distribution of the `Maternal Pregnancy Weight` column.\n\n```{python}\n#| code-fold: true\nbirths.head(5)\n```\n\nHow should we define our categories for this variable? In the previous example, these were the unique values of the `Maternal Smoker` column: `True` and `False`. If we use similar logic here, our categories are the different numerical weights contained in the `Maternal Pregnancy Weight` column.\n\nUnder this assumption, let's plot this distribution using the `seaborn.countplot` function.\n\n```{python}\nsns.countplot(data = births, x = 'Maternal Pregnancy Weight');\n```\n\nThis histogram clearly suffers from overplotting. This is somewhat expected for `Maternal Pregnancy Weight` - it is a quantitative variable that takes on a wide range of values.\n\nTo combat this problem, statisticians use bins to categorize numerical data. Luckily, `seaborn` provides a helpful plotting function that automatically bins our data.\n\n```{python}\nsns.histplot(data = births, x = \"Maternal Pregnancy Weight\");\n```\n\nThis diagram is known as a histogram. While it looks more reasonable, notice how we lose fine-grain information on the distribution of data contained within each bin. We can introduce rug plots to minimize this information loss. An overlaid \"rug plot\" displays the within-bin distribution of our data, as denoted by the thickness of the colored line on the x-axis.\n\n```{python}\nsns.histplot(data = births, x = \"Maternal Pregnancy Weight\");\nsns.rugplot(data = births, x = \"Maternal Pregnancy Weight\", color = 'red');\n```\n\nYou may have seen histograms drawn differently - perhaps with an overlaid **density curve** and normalized y-axis. We can display both with a few tweaks to our code. \n\nTo visualize a density curve, we can set the the `kde = True` argument of the `sns.histplot`. Setting the argument `stat = \"density\"` normalizes our histogram and displays densities, instead of counts, on the y-axis. You'll notice that the area under the density curve is 1.\n\n```{python}\nsns.histplot(data = births, x = \"Maternal Pregnancy Weight\", kde = True, \n             stat = \"density\")\nsns.rugplot(data = births, x = \"Maternal Pregnancy Weight\", color = 'red');\n```\n\n### Evaluating Histograms\n\nHistograms allow us to assess a distribution by their shape. There are a few properties of histograms we can analyze:\n\n1. Skewness and Tails\n    - Skewed left vs skewed right\n    - Left tail vs right tail\n2. Outliers\n    - Defined arbitrarily for now\n3. Modes\n    - Most commonly occuring data\n\n#### Skewness and Tails\n\nIf a distribution has a long right tail (such as `Maternal Pregancy Weight`), it is **skewed right**. In a right-skewed distribution, the few large outliers \"pull\" the mean to the **right** of the median.\n\nIf a distribution has a long left tail, it is **skewed left**. In a left-skewed distribution, the few small outliers \"pull\" the mean to the **left** of the median. \n\nIn the case where a distribution has equal-sized right and left tails, it is **symmetric**. The mean is approximately **equal** to the median.\n\n#### Outliers\n\nLoosely speaking, an **outlier** is defined as a data point that lies an abnormally large distance away from other values. We'll define the statistical measure for this shortly.\n\nOutliers disproportionately influce the mean because their magnitude is directly involved in computing the average. However, the median is largely unaffected - the magnitude of an outlier is irrelevant; we only care that it is some non-zero distance away from the midpoint of the data.\n\n#### Modes\n\nA **mode** of a distribution is a local or global maximum. A distribution with a single clear maximum is **unimodal**, distributions with two modes are **bimodal**, and those with 3 or more are **multimodal**.\n\nFor example, the distribution of birth weights for maternal smokers is (weakly) multimodal.\n\n```{python}\nbirths_maternal_smoker = births[births['Maternal Smoker'] == True]\nsns.histplot(data = births_maternal_smoker, x= 'Birth Weight');\n```\n\nOn the other hand, the distribution of birth weights for maternal non-smokers is unimodal.\n\n```{python}\nbirths_maternal_smoker = births[births['Maternal Smoker'] == False]\nsns.histplot(data = births_maternal_smoker, x= 'Birth Weight');\n```\n\n### Box Plots and Violin Plots\n\n#### Boxplots\n\n**Boxplots** are an alternative to histograms that visualize numerical distributions. They are especially useful in graphicaly summarizing several characteristics of a distribution. These include:\n\n1. Lower Quartile ($1$^st^ Quartile)\n2. Median ($2$^nd^ Quartile)\n3. Upper Quartile ($3$^rd^ Quartile)\n4. Interquartile Range (IQR)\n5. Whiskers\n6. Outliers\n\nThe **lower quartile**, **median**, and **uper quartile** are the $25$^th^, $50$^th^, and $75$^th^ percentiles of data, respectively. The **interquartile range** measures the spread of the middle $50$% of the distribution, calculated as the ($3$^rd^ Quartile $-$ $1$^st^ Quartile).\n\nThe **whiskers** of a box-plot are the two points that lie at the $1$^st^ Quartile $-$ ($1.5$ * IQR), and the $3$^rd^ Quartile $+$ ($1.5$ * IQR). They are the lower and upper ranges of \"normal\" data (the points excluding outliers). Subsequently, the **outliers** are the data points that fall beyond the whiskers, or further than ($1.5$ $*$ IQR) from the extreme quartiles.\n\nLet's visualize a box-plot of the `Birth Weight` column.\n\n```{python}\n#| code-fold: true\n\nimport numpy as np\n\nsns.boxplot(data = births, y = \"Birth Weight\");\n\nbweights = births['Birth Weight']\nq1 = np.percentile(bweights, 25)\nq2 = np.percentile(bweights, 50)\nq3 = np.percentile(bweights, 75)\niqr = q3 - q1\nwhisk1 = q1 - (1.5 * iqr)\nwhisk2 = q3 + (1.5 * iqr)\n\nprint(\"The first quartile is {}\".format(q1))\nprint(\"The second quartile is {}\".format(q2))\nprint(\"The third quartile is {}\".format(q3))\nprint(\"The interquartile range is {}\".format(iqr))\nprint(\"The whiskers are {} and {}\".format(whisk1, whisk2))\n```\n\nHere is a helpful visual that summarizes our discussion above.\n\n<img src=\"images/box-plot_vis.png\" alt='box-plot_vis' width='500'>\n\n#### Violin Plots\n\nAnother diagram that is useful in visualizing a variable's distribution is the violin plot. A **violin plot** supplements a box-plot with a smoothed density curve on either side of the plot. These density curves highlight the relative frequency of variable's possible values. If you look closely, you'll be able to discern the quartiles, whiskers, and other hallmark features of the box-plot.\n\n```{python}\nsns.violinplot(data = births, y = 'Birth Weight');\n```\n\n### Comparing Quantitative Distributions\n\nEarlier in our discussion of the mode, we visualized two histograms that described the distribution of birth weights for maternal smokers and non-smokers. However, comparing these histograms was difficult because they were displayed on seperate plots. Can we overlay the two to tell a more compelling story?\n\nIn `seaborn`, multiple calls to a plotting library in the same code cell will overlay the plots. For example:\n\n```{python}\nbirths_maternal_smoker = births[births['Maternal Smoker'] == False]\nbirths_non_maternal_smoker = births[births['Maternal Smoker'] == True]\n\nsns.histplot(data = births_maternal_smoker, x= 'Birth Weight',\n             color = 'orange', label = 'smoker')\nsns.histplot(data = births_non_maternal_smoker, x= 'Birth Weight',\n             color = 'blue', label = 'nonsmoker')\nplt.legend();\n```\n\nHowever, notice how this diagram suffers from overplotting. We can fix this with a call to `sns.kdeplot`. This will remove the bins and overlay the histogram with a density curve that better summarizes the distribution.\n\n```{python}\nsns.kdeplot(data = births_maternal_smoker, x= 'Birth Weight', color = 'orange', label = 'smoker')\nsns.kdeplot(data = births_non_maternal_smoker, x= 'Birth Weight', color = 'blue', label = 'nonsmoker')\nplt.legend();\n```\n\nUnfortunately, we lose critical information in our distribution by removing small details. Therefore, we typically prefer to use box-plots and violin plots when comparing distributions. These are more concise and allow us to compare summary statistics across many distributions.\n\n```{python}\nsns.violinplot(data=births, x='Maternal Smoker', y='Birth Weight');\n# The following line of code plots a box-plot\n#sns.boxplot(data=births, x='Maternal Smoker', y='Birth Weight');\n```\n\n### Relationships Between Quantitative Variables\n\nUp until now, we've discussed how to visualize single-variable distributions. Going beyond this, we want to understand the relationship between pairs of numerical variables.\n\n#### Scatter Plots\n\n**Scatter plots** are one of the most useful tools in representing the relationship between two quantitative variables. They are particularly important in gauging the strength, or correlation between variables. Knowledge of these relationships can then motivate decisions in our modeling process.\n\nFor example, let's plot a scatter plot comparing the `Maternal Pregnancy Weight` and `Birth Weight` colums, using both `matplotlib` and `seaborn`.\n\n```{python}\n# Matplotlib Example\nplt.scatter(births['Maternal Pregnancy Weight'], births['Birth Weight'])\n# For brevity, we have excluded code to label the axes\n```\n\n```{python}\n# Seaborn Example\nsns.scatterplot(data = births, x = \"Maternal Pregnancy Weight\", y = \"Birth Weight\",\n                hue = \"Maternal Smoker\")\n```\n\nThis is an example where color is used to add a third dimension to our plot. This is possible with the `hue` paramater in `seaborn`, which adds a categorical column encoding to an existing visualization. This way, we can look for relationships in `Maternal Pregnancy Weight` and `Birth Weight` in both maternal smokers and non-smokers. If we wish to see the relationship's strength more clearly, we can use `sns.lmplot`.\n\n```{python}\nsns.lmplot(data = births, x = \"Maternal Pregnancy Weight\", y = \"Birth Weight\", \n           hue=\"Maternal Smoker\", ci=False);\n```\n\nWe can make out a weak, positive relationship in pregnancy weight and birth weight for both maternal smokers and non-smokers (slightly more positive in maternal smokers).\n\n#### Hex Plots and Contour Plots\n\nUnfortunately, our scatter plots above suffered from overplotting, which made them hard to interpret. And with a large number of points, jittering is unlikely to resolve the issue. Instead, we can look to hex plots and contour plots.\n\n**Hex Plots** can be thought of as a two dimensional histogram that shows the joint distribution between two variables. This is particularly useful working with very dense data. \n\n```{python}\nsns.jointplot(data = births, x = \"Maternal Pregnancy Weight\", \n              y = \"Birth Weight\", kind = 'hex')\n```\n\nThe axes are evidently binned into hexagons, which makes the linear relationship easier to decipher. Darker regions generally indicate a higher density of points.\n\nOn the other hand, **contour plots** are two dimensional versions of density curves with marginal distributions of each variable on the axes. We've used very similar code here to generate our contour plots, with the addition of the `kind = 'kde'` and `fill = True` arguments.\n\n```{python}\nsns.jointplot(data = births, x = \"Maternal Pregnancy Weight\", \n              y = \"Birth Weight\", kind = 'kde', fill = True)\n```\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":5,"css":["../styles.css"],"output-file":"visualization_1.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.280","theme":["cosmo"],"callout-icon":false,"title":"Visualization I","jupyter":"python3","toc-location":"right"},"extensions":{"book":{"multiFile":true}}}}}