{
  "hash": "568c95fb7fba5a46d09d6b03d8ada3ae",
  "result": {
    "markdown": "---\ntitle: Pandas II\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    toc-location: right\n    code-fold: false\n    theme:\n      - cosmo\n      - cerulean\n    callout-icon: false\n---\n\n::: {.callout-note collapse=\"true\"}\n## Learning Outcomes\n* Build familiarity with advanced `pandas` syntax\n* Extract data from a DataFrame using conditional selection\n* Recognize situations where aggregation is useful and identify the correct technique for performing an aggregation\n:::\n\nLast time, we introduced the `pandas` library as a toolkit for processing data. We learned the DataFrame and Series data structures, familiarized ourselves with the basic syntax for manipulating tabular data, and began writing our first lines of `pandas` code.\n\n\nIn this lecture, we'll start to dive into some advanced `pandas` syntax. You may find it helpful to follow along with a notebook of your own as we walk through these new pieces of code.\n\nWe'll start by loading the `babynames` dataset.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport urllib.request\nimport os.path\nimport zipfile\n\ndata_url = \"https://www.ssa.gov/oact/babynames/state/namesbystate.zip\"\nlocal_filename = \"babynamesbystate.zip\"\nif not os.path.exists(local_filename): # if the data exists don't download again\n    with urllib.request.urlopen(data_url) as resp, open(local_filename, 'wb') as f:\n        f.write(resp.read())\n\nzf = zipfile.ZipFile(local_filename, 'r')\n\nca_name = 'CA.TXT'\nfield_names = ['State', 'Sex', 'Year', 'Name', 'Count']\nwith zf.open(ca_name) as fh:\n    babynames = pd.read_csv(fh, header=None, names=field_names)\n\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Conditional Selection\n\nConditional selection allows us to select a subset of rows in a DataFrame if they follow some specified condition.\n\nTo understand how to use conditional selection, we must look at another possible input of the `.loc` and `[]` methods – a boolean array, which is simply an array where each element is either `True` or `False`. This boolean array must have a length equal to the number of rows in the DataFrame. It will return all rows in the position of a corresponding True value in the array.\n\nTo see this in action, let's select all even-indexed rows in the first 10 rows of our DataFrame.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\n# Ask yourself: why is :9 is the correct slice to select the first 10 rows?\nbabynames_first_10_rows = babynames.loc[:9, :]\n\n# Notice how we have exactly 10 elements in our boolean array argument\nbabynames_first_10_rows[[True, False, True, False, True, False, True, False, True, False]]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Evelyn</td>\n      <td>126</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Virginia</td>\n      <td>101</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can perform a similar operation using `.loc`.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames_first_10_rows.loc[[True, False, True, False, True, False, True, False, True, False], :]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Evelyn</td>\n      <td>126</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Virginia</td>\n      <td>101</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThese techniques worked well in this example, but you can imagine how tedious it might be to list out `True`s and `False`s for every row in a larger DataFrame. To make things easier, we can instead provide a logical condition as an input to `.loc` or `[]` that returns a boolean array with the necessary length.\n\nFor example, to return all names associated with `F` sex:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\n# First, use a logical condition to generate a boolean array\nlogical_operator = (babynames[\"Sex\"] == \"F\")\n\n# Then, use this boolean array to filter the DataFrame\nbabynames[logical_operator].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nHere, `logical_operator` evaluates to a Series of boolean values with length 400762.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"false\"}\nprint(\"There are a total of {} values in 'logical_operator'\".format(len(logical_operator)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are a total of 400762 values in 'logical_operator'\n```\n:::\n:::\n\n\nRows starting at row 0 and ending at row 235790 evaluate to `True` and are thus returned in the DataFrame.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"The 0th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[0]))\nprint(\"The 235790th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[235790]))\nprint(\"The 235791th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[235791]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe 0th item in this 'logical_operator' is: True\nThe 235790th item in this 'logical_operator' is: True\nThe 235791th item in this 'logical_operator' is: False\n```\n:::\n:::\n\n\nPassing a Series as an argument to `babynames[]` has the same affect as using a boolean array. In fact, the `[]` selection operator can take a boolean Series, array, and list as arguments. These three are used interchangeably thoughout the course.\n\nWe can also use `.loc` to achieve similar results.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.loc[babynames[\"Sex\"] == \"F\"].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBoolean conditions can be combined using various operators that allow us to filter results by multiple conditions. Some examples include the `&` (and) operator and the `|` (or) operator.\n\n**Note:** When combining multiple conditions with logical operators, be sure to surround each condition with a set of parenthesis `()`. If you forget, your code will throw an error.\n\nFor example, if we want to return data on all females born before the 21st century, we can write:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[(babynames[\"Sex\"] == \"F\") & (babynames[\"Year\"] < 2000)].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBoolean array selection is a useful tool, but can lead to overly verbose code for complex conditions. `Pandas` provide many alternatives: \n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"false\"}\n(\n    babynames[(babynames[\"Name\"] == \"Bella\") | \n              (babynames[\"Name\"] == \"Alex\") |\n              (babynames[\"Name\"] == \"Ani\") |\n              (babynames[\"Name\"] == \"Lisa\")]\n).head()\n# Note: The parentheses surrounding the code make it possible to break the code on to multiple lines for readability\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6289</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1923</td>\n      <td>Bella</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>7512</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1925</td>\n      <td>Bella</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>12368</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1932</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>14741</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1936</td>\n      <td>Lisa</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>17084</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1939</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `.isin` function can be used to filter dataframes. The method helps in selecting rows with having a particular (or multiple) value in a particular column.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"false\"}\nnames = [\"Bella\", \"Alex\", \"Ani\", \"Lisa\"]\nbabynames[babynames[\"Name\"].isin(names)].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6289</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1923</td>\n      <td>Bella</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>7512</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1925</td>\n      <td>Bella</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>12368</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1932</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>14741</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1936</td>\n      <td>Lisa</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>17084</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1939</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe function `str.startswith` can be used to define a filter based on string values in a `Series` object. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[babynames[\"Name\"].str.startswith(\"N\")].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>76</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Norma</td>\n      <td>23</td>\n    </tr>\n    <tr>\n      <th>83</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nellie</td>\n      <td>20</td>\n    </tr>\n    <tr>\n      <th>127</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nina</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>198</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nora</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>310</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1911</td>\n      <td>Nellie</td>\n      <td>23</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Handy Utility Functions\n\n`pandas` contains an extensive library of functions that can help shorten the process of setting and getting information from its data structures. In the following section, we will give overviews of each of the main utility functions that will help us in Data 100.\n\n- `Numpy` and built-in function support\n- `.shape`\n- `.size`\n- `.describe() `\n- `.sample()`\n- `.value_counts()`\n- `.unique()`\n- `.sort_values()`\n\n### `Numpy`\n\n::: {.cell execution_count=12}\n``` {.python .cell-code code-fold=\"false\"}\nbella_counts = babynames[babynames[\"Name\"] == \"Bella\"][\"Count\"]\n```\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"false\"}\n# Average number of babies named Bella each year\nnp.mean(bella_counts)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n270.1860465116279\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code code-fold=\"false\"}\n# Max number of babies named Bella born on a given year\nmax(bella_counts)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n902\n```\n:::\n:::\n\n\n### `.shape` and `.size`\n\n`.shape` and `.size` are attributes of Series and DataFrames that measure the \"amount\" of data stored in the structure. Calling `.shape` returns a tuple containing the number of rows and columns present in the DataFrame or Series. `.size` is used to find the total number of elements in a structure, equivalent to the number of rows times the number of columns. \n\nMany functions strictly require the dimensions of the arguments along certain axes to match. Calling these dimension-finding functions is much faster than counting all of the items by hand.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n(400762, 5)\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.size\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n2003810\n```\n:::\n:::\n\n\n### `.describe()`\n\nIf many statistics are required from a DataFrame (minimum value, maximum value, mean value, etc.), then [`.describe()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html) can be used to compute all of them at once. \n\n::: {.cell execution_count=17}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>400762.000000</td>\n      <td>400762.000000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>1985.131287</td>\n      <td>79.953781</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>26.821004</td>\n      <td>295.414618</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>1910.000000</td>\n      <td>5.000000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1968.000000</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>1991.000000</td>\n      <td>13.000000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>2007.000000</td>\n      <td>38.000000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>2021.000000</td>\n      <td>8262.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nA different set of statistics will be reported if `.describe()` is called on a Series.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Sex\"].describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\ncount     400762\nunique         2\ntop            F\nfreq      235791\nName: Sex, dtype: object\n```\n:::\n:::\n\n\n### `.sample()`\n\nAs we will see later in the semester, random processes are at the heart of many data science techniques (for example, train-test splits, bootstrapping, and cross-validation). [`.sample()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html) lets us quickly select random entries (a row if called from a DataFrame, or a value if called from a Series).\n\n::: {.cell execution_count=19}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.sample()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>303462</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1985</td>\n      <td>Bryson</td>\n      <td>26</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.sample(5).iloc[:, 2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>121257</th>\n      <td>1992</td>\n      <td>Britni</td>\n      <td>23</td>\n    </tr>\n    <tr>\n      <th>6166</th>\n      <td>1923</td>\n      <td>Marietta</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>359745</th>\n      <td>2007</td>\n      <td>Osiris</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>55124</th>\n      <td>1967</td>\n      <td>Natalie</td>\n      <td>214</td>\n    </tr>\n    <tr>\n      <th>227123</th>\n      <td>2019</td>\n      <td>Ayanna</td>\n      <td>9</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[babynames[\"Year\"] == 2000].sample(4, replace = True).iloc[:, 2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>150721</th>\n      <td>2000</td>\n      <td>Alisia</td>\n      <td>13</td>\n    </tr>\n    <tr>\n      <th>339265</th>\n      <td>2000</td>\n      <td>Mohamed</td>\n      <td>41</td>\n    </tr>\n    <tr>\n      <th>150204</th>\n      <td>2000</td>\n      <td>Karolina</td>\n      <td>24</td>\n    </tr>\n    <tr>\n      <th>152700</th>\n      <td>2000</td>\n      <td>Ricki</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### `.value_counts()`\n\nWhen we want to know the distribution of the items in a Series (for example, what items are most/least common), we use [`.value-counts()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html) to get a breakdown of the unique *values* and their *counts*. In the example below, we can determine the name with the most years in which at least one person has taken that name by counting the number of times each name appears in the `\"Name\"` column of `babynames`.\n\n::: {.cell execution_count=22}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Name\"].value_counts().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\nJean         221\nFrancis      219\nGuadalupe    216\nJessie       215\nMarion       213\nName: Name, dtype: int64\n```\n:::\n:::\n\n\n### `.unique()`\n\nIf we have a Series with many repeated values, then [`.unique()`](https://pandas.pydata.org/docs/reference/api/pandas.unique.html)  can be used to identify only the *unique* values. Here we can get a list of all the names in `babynames`. \n\n**Exercise:** what function can we call on the Series below to get the number of unique names?\n\n::: {.cell execution_count=23}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Name\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray(['Mary', 'Helen', 'Dorothy', ..., 'Zyire', 'Zylo', 'Zyrus'],\n      dtype=object)\n```\n:::\n:::\n\n\n### `.sort_values()`\n\nOrdering a DataFrame can be useful for isolating extreme values. For example, the first 5 entries of a row sorted in descending order (that is, from highest to lowest) are the largest 5 values. [`.sort_values`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html) allows us to order a DataFrame or Series by a specified rule. For DataFrames, we must specify the column by which we want to compare the rows and the function will return such rows. We can choose to either receive the rows in `ascending` order (default) or `descending` order.\n\n::: {.cell execution_count=24}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.sort_values(by = \"Count\", ascending=False).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>263272</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1956</td>\n      <td>Michael</td>\n      <td>8262</td>\n    </tr>\n    <tr>\n      <th>264297</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1957</td>\n      <td>Michael</td>\n      <td>8250</td>\n    </tr>\n    <tr>\n      <th>313644</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1990</td>\n      <td>Michael</td>\n      <td>8247</td>\n    </tr>\n    <tr>\n      <th>278109</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1969</td>\n      <td>Michael</td>\n      <td>8244</td>\n    </tr>\n    <tr>\n      <th>279405</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1970</td>\n      <td>Michael</td>\n      <td>8197</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe do not need to explicitly specify the column used for sorting when calling `.value_counts()` on a Series. We can still specify the ordering paradigm – that is, whether values are sorted in ascending or descending order.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Name\"].sort_values(ascending=True).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n380256      Aadan\n362255      Aadan\n365374      Aadan\n394460    Aadarsh\n366561      Aaden\nName: Name, dtype: object\n```\n:::\n:::\n\n\n#### Sorting With a Custom Key\n\nUsing `.sort_values` can be useful in many situations, but it many not cover all use cases. This is because `pandas` automatically sorts values in order according to numeric value (for number data) or alphabetical order (for string data). The following code finds the top 5 most popular names in California in 2021.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code code-fold=\"false\"}\n# Sort names by count in year 2021\n# Recall that `.head(5)` displays the first five rows in the DataFrame\nbabynames[babynames[\"Year\"] == 2021].sort_values(\"Count\", ascending=False).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>397909</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>2021</td>\n      <td>Noah</td>\n      <td>2591</td>\n    </tr>\n    <tr>\n      <th>397910</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>2021</td>\n      <td>Liam</td>\n      <td>2469</td>\n    </tr>\n    <tr>\n      <th>232145</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>2021</td>\n      <td>Olivia</td>\n      <td>2395</td>\n    </tr>\n    <tr>\n      <th>232146</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>2021</td>\n      <td>Emma</td>\n      <td>2171</td>\n    </tr>\n    <tr>\n      <th>397911</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>2021</td>\n      <td>Mateo</td>\n      <td>2108</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThis offers us a lot of functionality, but what if we need to sort by some other metric? For example, what if we wanted to find the longest names in the DataFrame?\n\nWe can do this by specifying the `key` parameter of `.sort_values`. The `key` parameter is assigned to a function of our choice. This function is then applied to each value in the specified column. `pandas` will, finally, sort the DataFrame by the values outputted by the function.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code code-fold=\"false\"}\n# Here, a lambda function is applied to find the length of each value, `x`, in the \"Name\" column\nbabynames.sort_values(\"Name\", key=lambda x: x.str.len(), ascending=False).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>313143</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1989</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>333732</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>330421</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>323615</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>310235</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1988</td>\n      <td>Franciscojavier</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Adding and Removing Columns\n\nTo add a new column to a DataFrame, we use a syntax similar to that used when accessing an existing column. Specify the name of the new column by writing `dataframe[\"new_column\"]`, then assign this to a Series or Array containing the values that will populate this column.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code code-fold=\"false\"}\n# Add a column named \"name_lengths\" that includes the length of each name\nbabynames[\"name_lengths\"] = babynames[\"Name\"].str.len()\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n      <td>7</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Sort by the temporary column\nbabynames = babynames.sort_values(by = \"name_lengths\", ascending=False)\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>313143</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1989</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>333732</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>330421</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>323615</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>310235</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1988</td>\n      <td>Franciscojavier</td>\n      <td>10</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn the example above, we made use of an in-built function given to us by the `str` accessor for getting the length of names. Then we used `name_length` column to sort the dataframe. What if we had wanted to generate the values in our new column using a function of our own making?\n\nWe can do this using the Series [`.map`](https://pandas.pydata.org/docs/reference/api/pandas.Series.map.html) method. `.map` takes in a function as input, and will apply this function to each value of a Series. \n\nFor example, say we wanted to find the number of occurrences of the sequence \"dr\" or \"ea\" in each name. \n\n::: {.cell execution_count=30}\n``` {.python .cell-code code-fold=\"false\"}\n# First, define a function to count the number of times \"dr\" or \"ea\" appear in each name\ndef dr_ea_count(string):\n    return string.count(\"dr\") + string.count(\"ea\")\n\n# Then, use `map` to apply `dr_ea_count` to each name in the \"Name\" column\nbabynames[\"dr_ea_count\"] = babynames[\"Name\"].map(dr_ea_count)\n\n# Sort the DataFrame by the new \"dr_ea_count\" column so we can see our handiwork\nbabynames.sort_values(by = \"dr_ea_count\", ascending = False).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n      <th>dr_ea_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>101969</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1986</td>\n      <td>Deandrea</td>\n      <td>6</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>304390</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1985</td>\n      <td>Deandrea</td>\n      <td>6</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>131022</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1994</td>\n      <td>Leandrea</td>\n      <td>5</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>115950</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1990</td>\n      <td>Deandrea</td>\n      <td>5</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>108723</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1988</td>\n      <td>Deandrea</td>\n      <td>5</td>\n      <td>8</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we want to remove a column or row of a DataFrame, we can call the [`.drop`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html) method. Use the `axis` parameter to specify whether a column or row should be dropped. Unless otherwise specified, `pandas` will assume that we are dropping a row by default. \n\n::: {.cell execution_count=31}\n``` {.python .cell-code code-fold=\"false\"}\n# Drop our \"dr_ea_count\" and \"length\" columns from the DataFrame\nbabynames = babynames.drop([\"dr_ea_count\", \"name_lengths\"], axis=\"columns\")\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>313143</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1989</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>333732</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>330421</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>323615</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>310235</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1988</td>\n      <td>Franciscojavier</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNotice that we reassigned `babynames` to the result of `babynames.drop(...)`. This is a subtle, but important point: `pandas` table operations **do not occur in-place**. Calling `dataframe.drop(...)` will output a *copy* of `dataframe` with the row/column of interest removed, without modifying the original `dataframe` table. \n\nIn other words, if we simply call:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code code-fold=\"false\"}\n# This creates a copy of `babynames` and removes the row with label 3...\nbabynames.drop(3, axis=\"rows\")\n\n# ...but the original `babynames` is unchanged! \n# Notice that the row with label 3 is still present\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>313143</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1989</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>333732</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>330421</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>323615</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>310235</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1988</td>\n      <td>Franciscojavier</td>\n      <td>10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Aggregating Data with GroupBy\n\nUp until this point, we have been working with individual rows of DataFrames. As data scientists, we often wish to investigate trends across a larger *subset* of our data. For example, we may want to compute some summary statistic (the mean, median, sum, etc.) for a group of rows in our DataFrame. To do this, we'll use `pandas` `GroupBy` objects.\n\nLet's say we wanted to aggregate all rows in `babynames` for a given year. \n\n::: {.cell execution_count=33}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.groupby(\"Year\")\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n<pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001E880043640>\n```\n:::\n:::\n\n\nWhat does this strange output mean? Calling [`.groupby`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html) has generated a `GroupBy` object. You can imagine this as a set of \"mini\" sub-DataFrames, where each subframe contains all of the rows from `babynames` that correspond to a particular year. \n\nThe diagram below shows a simplified view of `babynames` to help illustrate this idea.\n\n![Creating a GroupBy object](images/gb.png)\n\nWe can't work with a `GroupBy` object directly – that is why you saw that strange output earlier, rather than a standard view of a DataFrame. To actually manipulate values within these \"mini\" DataFrames, we'll need to call an *aggregation method*. This is a method that tells `pandas` how to aggregate the values within the `GroupBy` object. Once the aggregation is applied, `pandas` will return a normal (now grouped) DataFrame.\n\nThe first aggregation method we'll consider is `.agg`. The `.agg` method takes in a function as its argument; this function is then applied to each column of a \"mini\" grouped DataFrame. We end up with a new DataFrame with one aggregated row per subframe. Let's see this in action by finding the `sum` of all counts for each year in `babynames` – this is equivalent to finding the number of babies born in each year. \n\n::: {.cell execution_count=34}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.groupby(\"Year\").agg(sum).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Year</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1910</th>\n      <td>9163</td>\n    </tr>\n    <tr>\n      <th>1911</th>\n      <td>9983</td>\n    </tr>\n    <tr>\n      <th>1912</th>\n      <td>17946</td>\n    </tr>\n    <tr>\n      <th>1913</th>\n      <td>22094</td>\n    </tr>\n    <tr>\n      <th>1914</th>\n      <td>26926</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can relate this back to the diagram we used above. Remember that the diagram uses a simplified version of `babynames`, which is why we see smaller values for the summed counts.\n\n![Performing an aggregation](images/agg.png)\n\nCalling `.agg` has condensed each subframe back into a single row. This gives us our final output: a DataFrame that is now indexed by `\"Year\"`, with a single row for each unique year in the original `babynames` DataFrame.\n\nYou may be wondering: where did the `\"State\"`, `\"Sex\"`, and `\"Name\"` columns go? Logically, it doesn't make sense to `sum` the string data in these columns (how would we add \"Mary\" + \"Ann\"?). Because of this, `pandas` will simply omit these columns when it performs the aggregation on the DataFrame. Since this happens implicitly, without the user specifying that these columns should be ignored, it's easy to run into troubling situations where columns are removed without the programmer noticing. It is better coding practice to select *only* the columns we care about before performing the aggregation.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code code-fold=\"false\"}\n# Same result, but now we explicitly tell Pandas to only consider the \"Count\" column when summing\nbabynames.groupby(\"Year\")[[\"Count\"]].agg(sum).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Year</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1910</th>\n      <td>9163</td>\n    </tr>\n    <tr>\n      <th>1911</th>\n      <td>9983</td>\n    </tr>\n    <tr>\n      <th>1912</th>\n      <td>17946</td>\n    </tr>\n    <tr>\n      <th>1913</th>\n      <td>22094</td>\n    </tr>\n    <tr>\n      <th>1914</th>\n      <td>26926</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Parting note\n\nManipulating `DataFrames` is a skill that is not mastered in just one day. Due to the flexibility of `pandas`, there are many different ways to get from a point A to a point B. We recommend trying multiple different ways to solve the same problem to gain even more practice and reach that point of mastery sooner.  \n\nNext, we will start digging deeper into the mechanics behind grouping data. \n\n",
    "supporting": [
      "pandas_2_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}