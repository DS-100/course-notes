{
  "hash": "2598bef7e18d66c607f8e9947c48b336",
  "result": {
    "markdown": "---\ntitle: Pandas II\nformat:\n  html:\n    toc: true\n    toc-depth: 5\n    toc-location: right\n    code-fold: false\n    theme:\n      - cosmo\n      - cerulean\n    callout-icon: false\n---\n\n::: {.callout-note collapse=\"false\"}\n## Learning Outcomes\n* Continue building familiarity with `pandas` syntax.\n* Extract data from a `DataFrame` using conditional selection.\n* Recognize situations where aggregation is useful and identify the correct technique for performing an aggregation.\n:::\n\nLast time, we introduced the `pandas` library as a toolkit for processing data. We learned the `DataFrame` and `Series` data structures, familiarized ourselves with the basic syntax for manipulating tabular data, and began writing our first lines of `pandas` code.\n\nIn this lecture, we'll start to dive into some advanced `pandas` syntax. You may find it helpful to follow along with a notebook of your own as we walk through these new pieces of code.\n\nWe'll start by loading the `babynames` dataset.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\n# This code pulls census data and loads it into a DataFrame\n# We won't cover it explicitly in this class, but you are welcome to explore it on your own\nimport pandas as pd\nimport numpy as np\nimport urllib.request\nimport os.path\nimport zipfile\n\ndata_url = \"https://www.ssa.gov/oact/babynames/state/namesbystate.zip\"\nlocal_filename = \"data/babynamesbystate.zip\"\nif not os.path.exists(local_filename): # If the data exists don't download again\n    with urllib.request.urlopen(data_url) as resp, open(local_filename, 'wb') as f:\n        f.write(resp.read())\n\nzf = zipfile.ZipFile(local_filename, 'r')\n\nca_name = 'STATE.CA.TXT'\nfield_names = ['State', 'Sex', 'Year', 'Name', 'Count']\nwith zf.open(ca_name) as fh:\n    babynames = pd.read_csv(fh, header=None, names=field_names)\n\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Conditional Selection\n\nConditional selection allows us to select a subset of rows in a `DataFrame` that satisfy some specified condition.\n\nTo understand how to use conditional selection, we must look at another possible input of the `.loc` and `[]` methods – a boolean array, which is simply an array or `Series` where each element is either `True` or `False`. This boolean array must have a length equal to the number of rows in the `DataFrame`. It will return all rows that correspond to a value of `True` in the array. We used a very similar technique when performing conditional extraction from a `Series` in the last lecture.\n\nTo see this in action, let's select all even-indexed rows in the first 10 rows of our `DataFrame`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code code-fold=\"false\"}\n# Ask yourself: why is :9 is the correct slice to select the first 10 rows?\nbabynames_first_10_rows = babynames.loc[:9, :]\n\n# Notice how we have exactly 10 elements in our boolean array argument\nbabynames_first_10_rows[[True, False, True, False, True, False, True, False, True, False]]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Evelyn</td>\n      <td>126</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Virginia</td>\n      <td>101</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can perform a similar operation using `.loc`.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames_first_10_rows.loc[[True, False, True, False, True, False, True, False, True, False], :]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Evelyn</td>\n      <td>126</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Virginia</td>\n      <td>101</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThese techniques worked well in this example, but you can imagine how tedious it might be to list out `True`s and `False`s for every row in a larger `DataFrame`. To make things easier, we can instead provide a logical condition as an input to `.loc` or `[]` that returns a boolean array with the necessary length.\n\nFor example, to return all names associated with `F` sex:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"false\"}\n# First, use a logical condition to generate a boolean array\nlogical_operator = (babynames[\"Sex\"] == \"F\")\n\n# Then, use this boolean array to filter the DataFrame\nbabynames[logical_operator].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nRecall from the previous lecture that `.head()` will return only the first few rows in the `DataFrame`. In reality, `babynames[logical operator]` contains as many rows as there are entries in the original `babynames` `DataFrame` with sex `\"F\"`.\n\nHere, `logical_operator` evaluates to a `Series` of boolean values with length 407428.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"There are a total of {} values in 'logical_operator'\".format(len(logical_operator)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThere are a total of 407428 values in 'logical_operator'\n```\n:::\n:::\n\n\nRows starting at row 0 and ending at row 239536 evaluate to `True` and are thus returned in the `DataFrame`. Rows from 239537 onwards evaluate to `False` and are omitted from the output.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"The 0th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[0]))\nprint(\"The 239536th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[239536]))\nprint(\"The 239537th item in this 'logical_operator' is: {}\".format(logical_operator.iloc[239537]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe 0th item in this 'logical_operator' is: True\nThe 239536th item in this 'logical_operator' is: True\nThe 239537th item in this 'logical_operator' is: False\n```\n:::\n:::\n\n\nPassing a `Series` as an argument to `babynames[]` has the same effect as using a boolean array. In fact, the `[]` selection operator can take a boolean `Series`, array, and list as arguments. These three are used interchangeably throughout the course.\n\nWe can also use `.loc` to achieve similar results.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.loc[babynames[\"Sex\"] == \"F\"].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBoolean conditions can be combined using various bitwise operators, allowing us to filter results by multiple conditions. In the table below, p and q are boolean arrays or `Series`.\n\nSymbol | Usage      | Meaning \n------ | ---------- | -------------------------------------\n~    | ~p       | Returns negation of p\n&#124; | p &#124; q | p OR q\n&    | p & q    | p AND q\n^  | p ^ q | p XOR q (exclusive or)\n\nWhen combining multiple conditions with logical operators, we surround each individual condition with a set of parenthesis `()`. This imposes an order of operations on `pandas` evaluating your logic and can avoid code erroring.\n\nFor example, if we want to return data on all names with sex `\"F\"` born before the year 2000, we can write:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[(babynames[\"Sex\"] == \"F\") & (babynames[\"Year\"] < 2000)].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we want to return data on all names with sex `\"F\"` *or* all born before the year 2000, we can write:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[(babynames[\"Sex\"] == \"F\") | (babynames[\"Year\"] < 2000)].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBoolean array selection is a useful tool, but can lead to overly verbose code for complex conditions. In the example below, our boolean condition is long enough to extend for several lines of code.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code code-fold=\"false\"}\n# Note: The parentheses surrounding the code make it possible to break the code on to multiple lines for readability\n(\n    babynames[(babynames[\"Name\"] == \"Bella\") | \n              (babynames[\"Name\"] == \"Alex\") |\n              (babynames[\"Name\"] == \"Ani\") |\n              (babynames[\"Name\"] == \"Lisa\")]\n).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6289</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1923</td>\n      <td>Bella</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>7512</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1925</td>\n      <td>Bella</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>12368</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1932</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>14741</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1936</td>\n      <td>Lisa</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>17084</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1939</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n Fortunately, `pandas` provides many alternative methods for constructing boolean filters.\n \nThe `.isin` function is one such example. This method evaluates if the values in a `Series` are contained in a different sequence (list, array, or `Series`) of values. In the cell below, we achieve equivalent results to the `DataFrame` above with far more concise code.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code code-fold=\"false\"}\nnames = [\"Bella\", \"Alex\", \"Narges\", \"Lisa\"]\nbabynames[\"Name\"].isin(names).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n0    False\n1    False\n2    False\n3    False\n4    False\nName: Name, dtype: bool\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nbabynames[babynames[\"Name\"].isin(names)].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>6289</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1923</td>\n      <td>Bella</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>7512</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1925</td>\n      <td>Bella</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>12368</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1932</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>14741</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1936</td>\n      <td>Lisa</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>17084</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1939</td>\n      <td>Lisa</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe function `str.startswith` can be used to define a filter based on string values in a `Series` object. It checks to see if string values in a `Series` start with a particular character.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code code-fold=\"false\"}\n# Identify whether names begin with the letter \"N\"\nbabynames[\"Name\"].str.startswith(\"N\").head()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0    False\n1    False\n2    False\n3    False\n4    False\nName: Name, dtype: bool\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# Extracting names that begin with the letter \"N\"\nbabynames[babynames[\"Name\"].str.startswith(\"N\")].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>76</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Norma</td>\n      <td>23</td>\n    </tr>\n    <tr>\n      <th>83</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nellie</td>\n      <td>20</td>\n    </tr>\n    <tr>\n      <th>127</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nina</td>\n      <td>11</td>\n    </tr>\n    <tr>\n      <th>198</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Nora</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>310</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1911</td>\n      <td>Nellie</td>\n      <td>23</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Adding, Removing, and Modifying Columns\n\nIn many data science tasks, we may need to change the columns contained in our `DataFrame` in some way. Fortunately, the syntax to do so is fairly straightforward.\n\nTo add a new column to a `DataFrame`, we use a syntax similar to that used when accessing an existing column. Specify the name of the new column by writing `df[\"column\"]`, then assign this to a `Series` or array containing the values that will populate this column.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code code-fold=\"false\"}\n# Create a Series of the length of each name. \nbabyname_lengths = babynames[\"Name\"].str.len()\n\n# Add a column named \"name_lengths\" that includes the length of each name\nbabynames[\"name_lengths\"] = babyname_lengths\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n      <td>7</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we need to later modify an existing column, we can do so by referencing this column again with the syntax `df[\"column\"]`, then re-assigning it to a new `Series` or array of the appropriate length.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code code-fold=\"false\"}\n# Modify the “name_lengths” column to be one less than its original value\nbabynames[\"name_lengths\"] = babynames[\"name_lengths\"] - 1\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can rename a column using the `.rename()` method. `.rename()` takes in a dictionary that maps old column names to their new ones.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code code-fold=\"false\"}\n# Rename “name_lengths” to “Length”\nbabynames = babynames.rename(columns={\"name_lengths\":\"Length\"})\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>Length</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we want to remove a column or row of a `DataFrame`, we can call the [`.drop`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html) method. Use the `axis` parameter to specify whether a column or row should be dropped. Unless otherwise specified, `pandas` will assume that we are dropping a row by default. \n\n::: {.cell execution_count=18}\n``` {.python .cell-code code-fold=\"false\"}\n# Drop our new \"Length\" column from the DataFrame\nbabynames = babynames.drop(\"Length\", axis=\"columns\")\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNotice that we *re-assigned* `babynames` to the result of `babynames.drop(...)`. This is a subtle but important point: `pandas` table operations **do not occur in-place**. Calling `df.drop(...)` will output a *copy* of `df` with the row/column of interest removed without modifying the original `df` table. \n\nIn other words, if we simply call:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code code-fold=\"false\"}\n# This creates a copy of `babynames` and removes the column \"Name\"...\nbabynames.drop(\"Name\", axis=\"columns\")\n\n# ...but the original `babynames` is unchanged! \n# Notice that the \"Name\" column is still present\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Handy Utility Functions\n\n`pandas` contains an extensive library of functions that can help shorten the process of setting and getting information from its data structures. In the following section, we will give overviews of each of the main utility functions that will help us in Data 100.\n\nDiscussing all functionality offered by `pandas` could take an entire semester! We will walk you through the most commonly-used functions and encourage you to explore and experiment on your own. \n\n- `NumPy` and built-in function support\n- `.shape`\n- `.size`\n- `.describe() `\n- `.sample()`\n- `.value_counts()`\n- `.unique()`\n- `.sort_values()`\n\nThe `pandas` [documentation](https://pandas.pydata.org/docs/reference/index.html) will be a valuable resource in Data 100 and beyond.\n\n### `NumPy`\n\n`pandas` is designed to work well with `NumPy`, the framework for array computations you encountered in [Data 8](https://www.data8.org/su23/reference/#array-functions-and-methods). Just about any `NumPy` function can be applied to `pandas` `DataFrame`s and `Series`.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code code-fold=\"false\"}\n# Pull out the number of babies named Yash each year\nyash_count = babynames[babynames[\"Name\"] == \"Yash\"][\"Count\"]\nyash_count.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n331824     8\n334114     9\n336390    11\n338773    12\n341387    10\nName: Count, dtype: int64\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code code-fold=\"false\"}\n# Average number of babies named Yash each year\nnp.mean(yash_count)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n17.142857142857142\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code code-fold=\"false\"}\n# Max number of babies named Yash born in any one year\nnp.max(yash_count)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n29\n```\n:::\n:::\n\n\n### `.shape` and `.size`\n\n`.shape` and `.size` are attributes of `Series` and `DataFrame`s that measure the \"amount\" of data stored in the structure. Calling `.shape` returns a tuple containing the number of rows and columns present in the `DataFrame` or `Series`. `.size` is used to find the total number of elements in a structure, equivalent to the number of rows times the number of columns. \n\nMany functions strictly require the dimensions of the arguments along certain axes to match. Calling these dimension-finding functions is much faster than counting all of the items by hand.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code code-fold=\"false\"}\n# Return the shape of the DataFrame, in the format (num_rows, num_columns)\nbabynames.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n(407428, 5)\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code code-fold=\"false\"}\n# Return the size of the DataFrame, equal to num_rows * num_columns\nbabynames.size\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n2037140\n```\n:::\n:::\n\n\n### `.describe()`\n\nIf many statistics are required from a `DataFrame` (minimum value, maximum value, mean value, etc.), then [`.describe()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html) can be used to compute all of them at once. \n\n::: {.cell execution_count=25}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>407428.000000</td>\n      <td>407428.000000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>1985.733609</td>\n      <td>79.543456</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>27.007660</td>\n      <td>293.698654</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>1910.000000</td>\n      <td>5.000000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1969.000000</td>\n      <td>7.000000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>1992.000000</td>\n      <td>13.000000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>2008.000000</td>\n      <td>38.000000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>2022.000000</td>\n      <td>8260.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nA different set of statistics will be reported if `.describe()` is called on a `Series`.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Sex\"].describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\ncount     407428\nunique         2\ntop            F\nfreq      239537\nName: Sex, dtype: object\n```\n:::\n:::\n\n\n### `.sample()`\n\nAs we will see later in the semester, random processes are at the heart of many data science techniques (for example, train-test splits, bootstrapping, and cross-validation). [`.sample()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html) lets us quickly select random entries (a row if called from a `DataFrame`, or a value if called from a `Series`).\n\nBy default, `.sample()` selects entries *without* replacement. Pass in the argument `replace=True` to sample with replacement.\n\n::: {.cell execution_count=27}\n``` {.python .cell-code code-fold=\"false\"}\n# Sample a single row\nbabynames.sample()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>108524</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1988</td>\n      <td>Monae</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNaturally, this can be chained with other methods and operators (`iloc`, etc.).\n\n::: {.cell execution_count=28}\n``` {.python .cell-code code-fold=\"false\"}\n# Sample 5 random rows, and select all columns after column 2\nbabynames.sample(5).iloc[:, 2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>156036</th>\n      <td>2001</td>\n      <td>Vivika</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>333676</th>\n      <td>1996</td>\n      <td>Ever</td>\n      <td>14</td>\n    </tr>\n    <tr>\n      <th>130586</th>\n      <td>1994</td>\n      <td>Lilyanne</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>63592</th>\n      <td>1971</td>\n      <td>Annie</td>\n      <td>42</td>\n    </tr>\n    <tr>\n      <th>397059</th>\n      <td>2019</td>\n      <td>Jordy</td>\n      <td>20</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code code-fold=\"false\"}\n# Randomly sample 4 names from the year 2000, with replacement, and select all columns after column 2\nbabynames[babynames[\"Year\"] == 2000].sample(4, replace = True).iloc[:, 2:]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>152461</th>\n      <td>2000</td>\n      <td>Gisella</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>344604</th>\n      <td>2000</td>\n      <td>Ziad</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>344528</th>\n      <td>2000</td>\n      <td>Naman</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>149984</th>\n      <td>2000</td>\n      <td>Katharine</td>\n      <td>33</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### `.value_counts()`\n\nThe [`Series.value_counts()`](https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html) method counts the number of occurrence of each unique value in a `Series`. In other words, it *counts* the number of times each unique *value* appears. This is often useful for determining the most or least common entries in a `Series`.\n\nIn the example below, we can determine the name with the most years in which at least one person has taken that name by counting the number of times each name appears in the `\"Name\"` column of `babynames`. Note that the return value is also a `Series`.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Name\"].value_counts().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\nJean         223\nFrancis      221\nGuadalupe    218\nJessie       217\nMarion       214\nName: Name, dtype: int64\n```\n:::\n:::\n\n\n### `.unique()`\n\nIf we have a `Series` with many repeated values, then [`.unique()`](https://pandas.pydata.org/docs/reference/api/pandas.unique.html) can be used to identify only the *unique* values. Here we return an array of all the names in `babynames`. \n\n::: {.cell execution_count=31}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[\"Name\"].unique()\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\narray(['Mary', 'Helen', 'Dorothy', ..., 'Zae', 'Zai', 'Zayvier'],\n      dtype=object)\n```\n:::\n:::\n\n\n### `.sort_values()`\n\nOrdering a `DataFrame` can be useful for isolating extreme values. For example, the first 5 entries of a row sorted in descending order (that is, from highest to lowest) are the largest 5 values. [`.sort_values`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html) allows us to order a `DataFrame` or `Series` by a specified column. We can choose to either receive the rows in `ascending` order (default) or `descending` order.\n\n::: {.cell execution_count=32}\n``` {.python .cell-code code-fold=\"false\"}\n# Sort the \"Count\" column from highest to lowest\nbabynames.sort_values(by=\"Count\", ascending=False).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>268041</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1957</td>\n      <td>Michael</td>\n      <td>8260</td>\n    </tr>\n    <tr>\n      <th>267017</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1956</td>\n      <td>Michael</td>\n      <td>8258</td>\n    </tr>\n    <tr>\n      <th>317387</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1990</td>\n      <td>Michael</td>\n      <td>8246</td>\n    </tr>\n    <tr>\n      <th>281850</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1969</td>\n      <td>Michael</td>\n      <td>8245</td>\n    </tr>\n    <tr>\n      <th>283146</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1970</td>\n      <td>Michael</td>\n      <td>8196</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nUnlike when calling `.value_counts()` on a `DataFrame`, we do not need to explicitly specify the column used for sorting when calling `.value_counts()` on a `Series`. We can still specify the ordering paradigm – that is, whether values are sorted in ascending or descending order.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code code-fold=\"false\"}\n# Sort the \"Name\" Series alphabetically\nbabynames[\"Name\"].sort_values(ascending=True).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n366001      Aadan\n384005      Aadan\n369120      Aadan\n398211    Aadarsh\n370306      Aaden\nName: Name, dtype: object\n```\n:::\n:::\n\n\n## Custom Sorts\n\nLet's now try applying what we've just learned to solve a sorting problem using different approaches. Assume we want to find the longest baby names and sort our data accordingly.\n\n### Approach 1: Create a Temporary Column\n\nOne method to do this is to first start by creating a column that contains the lengths of the names. \n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Create a Series of the length of each name\nbabyname_lengths = babynames[\"Name\"].str.len()\n\n# Add a column named \"name_lengths\" that includes the length of each name\nbabynames[\"name_lengths\"] = babyname_lengths\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Mary</td>\n      <td>295</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Helen</td>\n      <td>239</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Dorothy</td>\n      <td>220</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Margaret</td>\n      <td>163</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1910</td>\n      <td>Frances</td>\n      <td>134</td>\n      <td>7</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can then sort the `DataFrame` by that column using `.sort_values()`:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Sort by the temporary column\nbabynames = babynames.sort_values(by=\"name_lengths\", ascending=False)\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>name_lengths</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>334166</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>337301</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Franciscojavier</td>\n      <td>5</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>339472</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1998</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>321792</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1991</td>\n      <td>Ryanchristopher</td>\n      <td>7</td>\n      <td>15</td>\n    </tr>\n    <tr>\n      <th>327358</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n      <td>15</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFinally, we can drop the `name_length` column from `babynames` to prevent our table from getting cluttered.\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Drop the 'name_length' column\nbabynames = babynames.drop(\"name_lengths\", axis='columns')\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>334166</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>337301</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Franciscojavier</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>339472</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1998</td>\n      <td>Franciscojavier</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>321792</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1991</td>\n      <td>Ryanchristopher</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>327358</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Johnchristopher</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Approach 2: Sorting using the `key` Argument\n\nAnother way to approach this is to use the `key` argument of `.sort_values()`. Here we can specify that we want to sort `\"Name\"` values by their length.\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nbabynames.sort_values(\"Name\", key=lambda x: x.str.len(), ascending=False).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>334166</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1996</td>\n      <td>Franciscojavier</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>327472</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1993</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>337301</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Franciscojavier</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>337477</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1997</td>\n      <td>Ryanchristopher</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>312543</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1987</td>\n      <td>Franciscojavier</td>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Approach 3: Sorting using the `map` Function\n\nWe can also use the `map` function on a `Series` to solve this. Say we want to sort the `babynames` table by the number of `\"dr\"`'s and `\"ea\"`s in each `\"Name\"`. We'll define the function `dr_ea_count` to help us out.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\n# First, define a function to count the number of times \"dr\" or \"ea\" appear in each name\ndef dr_ea_count(string):\n    return string.count('dr') + string.count('ea')\n\n# Then, use `map` to apply `dr_ea_count` to each name in the \"Name\" column\nbabynames[\"dr_ea_count\"] = babynames[\"Name\"].map(dr_ea_count)\n\n# Sort the DataFrame by the new \"dr_ea_count\" column so we can see our handiwork\nbabynames = babynames.sort_values(by=\"dr_ea_count\", ascending=False)\nbabynames.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n      <th>dr_ea_count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>115957</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1990</td>\n      <td>Deandrea</td>\n      <td>5</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>101976</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1986</td>\n      <td>Deandrea</td>\n      <td>6</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>131029</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1994</td>\n      <td>Leandrea</td>\n      <td>5</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>108731</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1988</td>\n      <td>Deandrea</td>\n      <td>5</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>308131</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1985</td>\n      <td>Deandrea</td>\n      <td>6</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can drop the `dr_ea_count` once we're done using it to maintain a neat table.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\n# Drop the `dr_ea_count` column\nbabynames = babynames.drop(\"dr_ea_count\", axis = 'columns')\nbabynames.head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>State</th>\n      <th>Sex</th>\n      <th>Year</th>\n      <th>Name</th>\n      <th>Count</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>115957</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1990</td>\n      <td>Deandrea</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>101976</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1986</td>\n      <td>Deandrea</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>131029</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1994</td>\n      <td>Leandrea</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>108731</th>\n      <td>CA</td>\n      <td>F</td>\n      <td>1988</td>\n      <td>Deandrea</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>308131</th>\n      <td>CA</td>\n      <td>M</td>\n      <td>1985</td>\n      <td>Deandrea</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Aggregating Data with `.groupby`\n\nUp until this point, we have been working with individual rows of `DataFrame`s. As data scientists, we often wish to investigate trends across a larger *subset* of our data. For example, we may want to compute some summary statistic (the mean, median, sum, etc.) for a group of rows in our `DataFrame`. To do this, we'll use `pandas` `GroupBy` objects.\n\nLet's say we wanted to aggregate all rows in `babynames` for a given year. \n\n::: {.cell execution_count=40}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.groupby(\"Year\")\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n<pandas.core.groupby.generic.DataFrameGroupBy object at 0x7f7ab3113250>\n```\n:::\n:::\n\n\nWhat does this strange output mean? Calling [`.groupby`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html) has generated a `GroupBy` object. You can imagine this as a set of \"mini\" sub-DataFrames, where each subframe contains all of the rows from `babynames` that correspond to a particular year. \n\nThe diagram below shows a simplified view of `babynames` to help illustrate this idea.\n\n![Creating a GroupBy object](images/gb.png)\n\nWe can't work with a `GroupBy` object directly – that is why you saw that strange output earlier rather than a standard view of a `DataFrame`. To actually manipulate values within these \"mini\" DataFrames, we'll need to call an *aggregation method*. This is a method that tells `pandas` how to aggregate the values within the `GroupBy` object. Once the aggregation is applied, `pandas` will return a normal (now grouped) `DataFrame`.\n\nThe first aggregation method we'll consider is `.agg`. The `.agg` method takes in a function as its argument; this function is then applied to each column of a \"mini\" grouped DataFrame. We end up with a new `DataFrame` with one aggregated row per subframe. Let's see this in action by finding the `sum` of all counts for each year in `babynames` – this is equivalent to finding the number of babies born in each year. \n\n::: {.cell execution_count=41}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames[[\"Year\", \"Count\"]].groupby(\"Year\").agg(sum).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Year</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1910</th>\n      <td>9163</td>\n    </tr>\n    <tr>\n      <th>1911</th>\n      <td>9983</td>\n    </tr>\n    <tr>\n      <th>1912</th>\n      <td>17946</td>\n    </tr>\n    <tr>\n      <th>1913</th>\n      <td>22094</td>\n    </tr>\n    <tr>\n      <th>1914</th>\n      <td>26926</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can relate this back to the diagram we used above. Remember that the diagram uses a simplified version of `babynames`, which is why we see smaller values for the summed counts.\n\n![Performing an aggregation](images/agg.png)\n\nCalling `.agg` has condensed each subframe back into a single row. This gives us our final output: a `DataFrame` that is now indexed by `\"Year\"`, with a single row for each unique year in the original `babynames` DataFrame.\n\nYou may be wondering: where did the `\"State\"`, `\"Sex\"`, and `\"Name\"` columns go? Logically, it doesn't make sense to `sum` the string data in these columns (how would we add \"Mary\" + \"Ann\"?). Because of this, we need to omit these columns when we perform aggregation on the `DataFrame`.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code code-fold=\"false\"}\n# Same result, but now we explicitly tell pandas to only consider the \"Count\" column when summing\nbabynames.groupby(\"Year\")[[\"Count\"]].agg(sum).head(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Year</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1910</th>\n      <td>9163</td>\n    </tr>\n    <tr>\n      <th>1911</th>\n      <td>9983</td>\n    </tr>\n    <tr>\n      <th>1912</th>\n      <td>17946</td>\n    </tr>\n    <tr>\n      <th>1913</th>\n      <td>22094</td>\n    </tr>\n    <tr>\n      <th>1914</th>\n      <td>26926</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThere are many different aggregations that can be applied to the grouped data. The primary requirement is that an aggregation function must:\n\n* Take in a `Series` of data (a single column of the grouped subframe).\n* Return a single value that aggregates this `Series`.\n\nBecause of this fairly broad requirement, `pandas` offers many ways of computing an aggregation.\n\n**In-built** Python operations – such as `sum`, `max`, and `min` – are automatically recognized by `pandas`.\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\n# What is the minimum count for each name in any year?\nbabynames.groupby(\"Name\")[[\"Count\"]].agg(min).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\n# What is the largest single-year count of each name?\nbabynames.groupby(\"Name\")[[\"Count\"]].agg(max).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>158</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>8</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nAs mentioned previously, functions from the `NumPy` library, such as `np.mean`, `np.max`, `np.min`, and `np.sum`, are also fair game in `pandas`.\n\n::: {.cell execution_count=45}\n``` {.python .cell-code code-fold=\"false\"}\n# What is the average count for each name across all years?\nbabynames.groupby(\"Name\")[[\"Count\"]].agg(np.mean).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>6.000000</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>6.000000</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>46.214286</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>6.750000</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>6.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n`pandas` also offers a number of in-built functions. Functions that are native to `pandas` can be referenced using their string name within a call to `.agg`. Some examples include:\n\n* `.agg(\"sum\")`\n* `.agg(\"max\")`\n* `.agg(\"min\")`\n* `.agg(\"mean\")`\n* `.agg(\"first\")`\n* `.agg(\"last\")`\n\nThe latter two entries in this list – `\"first\"` and `\"last\"` – are unique to `pandas`. They return the first or last entry in a subframe column. Why might this be useful? Consider a case where *multiple* columns in a group share identical information. To represent this information in the grouped output, we can simply grab the first or last entry, which we know will be identical to all other entries.\n\nLet's illustrate this with an example. Say we add a new column to `babynames` that contains the first letter of each name. \n\n::: {.cell execution_count=46}\n``` {.python .cell-code code-fold=\"false\"}\n# Imagine we had an additional column, \"First Letter\". We'll explain this code next week\nbabynames[\"First Letter\"] = babynames[\"Name\"].str[0]\n\n# We construct a simplified DataFrame containing just a subset of columns\nbabynames_new = babynames[[\"Name\", \"First Letter\", \"Year\"]]\nbabynames_new.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>First Letter</th>\n      <th>Year</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>115957</th>\n      <td>Deandrea</td>\n      <td>D</td>\n      <td>1990</td>\n    </tr>\n    <tr>\n      <th>101976</th>\n      <td>Deandrea</td>\n      <td>D</td>\n      <td>1986</td>\n    </tr>\n    <tr>\n      <th>131029</th>\n      <td>Leandrea</td>\n      <td>L</td>\n      <td>1994</td>\n    </tr>\n    <tr>\n      <th>108731</th>\n      <td>Deandrea</td>\n      <td>D</td>\n      <td>1988</td>\n    </tr>\n    <tr>\n      <th>308131</th>\n      <td>Deandrea</td>\n      <td>D</td>\n      <td>1985</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIf we form groups for each name in the dataset, `\"First Letter\"` will be the same for all members of the group. This means that if we simply select the first entry for `\"First Letter\"` in the group, we'll represent all data in that group. \n\nWe can use a dictionary to apply different aggregation functions to each column during grouping.\n\n![Aggregating using \"first\"](images/first.png)\n\n::: {.cell execution_count=47}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames_new.groupby(\"Name\").agg({\"First Letter\":\"first\", \"Year\":\"max\"}).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>First Letter</th>\n      <th>Year</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>A</td>\n      <td>2014</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>A</td>\n      <td>2019</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>A</td>\n      <td>2020</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>A</td>\n      <td>2019</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>A</td>\n      <td>2022</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nSome aggregation functions are common enough that `pandas` allows them to be called directly, without the explicit use of `.agg`.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames.groupby(\"Name\")[[\"Count\"]].mean().head()\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>6.000000</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>6.000000</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>46.214286</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>6.750000</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>6.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe can also define aggregation functions of our own! This can be done using either a `def` or `lambda` statement. Again, the condition for a custom aggregation function is that it must take in a `Series` and output a single scalar value.\n\n::: {.cell execution_count=49}\n``` {.python .cell-code code-fold=\"false\"}\nbabynames = babynames.sort_values(by=\"Year\", ascending=True)\ndef ratio_to_peak(series):\n    return series.iloc[-1]/max(series)\n\nbabynames.groupby(\"Name\")[[\"Year\", \"Count\"]].agg(ratio_to_peak)\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>1.0</td>\n      <td>0.714286</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>1.0</td>\n      <td>0.063291</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>1.0</td>\n      <td>0.750000</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>Zymir</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyon</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyra</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyrah</th>\n      <td>1.0</td>\n      <td>0.833333</td>\n    </tr>\n    <tr>\n      <th>Zyrus</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n<p>20437 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code code-fold=\"false\"}\n# Alternatively, using lambda\nbabynames.groupby(\"Name\")[[\"Year\", \"Count\"]].agg(lambda s: s.iloc[-1]/max(s))\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Year</th>\n      <th>Count</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Aadan</th>\n      <td>1.0</td>\n      <td>0.714286</td>\n    </tr>\n    <tr>\n      <th>Aadarsh</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Aaden</th>\n      <td>1.0</td>\n      <td>0.063291</td>\n    </tr>\n    <tr>\n      <th>Aadhav</th>\n      <td>1.0</td>\n      <td>0.750000</td>\n    </tr>\n    <tr>\n      <th>Aadhini</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>Zymir</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyon</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyra</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n    <tr>\n      <th>Zyrah</th>\n      <td>1.0</td>\n      <td>0.833333</td>\n    </tr>\n    <tr>\n      <th>Zyrus</th>\n      <td>1.0</td>\n      <td>1.000000</td>\n    </tr>\n  </tbody>\n</table>\n<p>20437 rows × 2 columns</p>\n</div>\n```\n:::\n:::\n\n\n## Parting Note\n\nManipulating `DataFrames` is not a skill that is mastered in just one day. Due to the flexibility of `pandas`, there are many different ways to get from point A to point B. We recommend trying multiple different ways to solve the same problem to gain even more practice and reach that point of mastery sooner.  \n\nNext, we will start digging deeper into the mechanics behind grouping data. \n\n",
    "supporting": [
      "pandas_2_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}