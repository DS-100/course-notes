<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Probability II</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="probability_2_files/libs/clipboard/clipboard.min.js"></script>
<script src="probability_2_files/libs/quarto-html/quarto.js"></script>
<script src="probability_2_files/libs/quarto-html/popper.min.js"></script>
<script src="probability_2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="probability_2_files/libs/quarto-html/anchor.min.js"></script>
<link href="probability_2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="probability_2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="probability_2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="probability_2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="probability_2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Probability II</h2>
   
  <ul>
  <li><a href="#sample-statistics" id="toc-sample-statistics" class="nav-link active" data-scroll-target="#sample-statistics">Sample Statistics</a></li>
  <li><a href="#prediction-and-inference" id="toc-prediction-and-inference" class="nav-link" data-scroll-target="#prediction-and-inference">Prediction and Inference</a></li>
  <li><a href="#modeling-as-estimation" id="toc-modeling-as-estimation" class="nav-link" data-scroll-target="#modeling-as-estimation">Modeling as Estimation</a></li>
  <li><a href="#the-bias-variance-trade-off" id="toc-the-bias-variance-trade-off" class="nav-link" data-scroll-target="#the-bias-variance-trade-off">The Bias Variance Trade-off</a>
  <ul class="collapse">
  <li><a href="#model-risk" id="toc-model-risk" class="nav-link" data-scroll-target="#model-risk">Model Risk</a></li>
  <li><a href="#the-three-components-of-model-risk" id="toc-the-three-components-of-model-risk" class="nav-link" data-scroll-target="#the-three-components-of-model-risk">The Three Components of Model Risk</a></li>
  <li><a href="#observation-variance" id="toc-observation-variance" class="nav-link" data-scroll-target="#observation-variance">Observation Variance</a></li>
  <li><a href="#bias" id="toc-bias" class="nav-link" data-scroll-target="#bias">Bias</a></li>
  <li><a href="#model-variance" id="toc-model-variance" class="nav-link" data-scroll-target="#model-variance">Model Variance</a></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting it all together</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Probability II</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<div class="callout-note callout callout-style-default no-icon callout-captioned">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Learning Outcomes
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ul>
<li>Apply the Central Limit Theorem to approximate parameters of a population</li>
<li>Compute the bias, variance, and MSE of an estimator for a parameter</li>
<li>Qualitiatively describe the bias-variance tradeoff and decomposition of model risk</li>
<li>Construct confidence intervals for hypothesis testing</li>
</ul>
</div>
</div>
</div>
<p>Last time, we introduced the idea of random variables: numerical functions of a sample. Most of our work in the last lecture was done to build a background in probability and statistics. Now that we’ve established some key ideas, we’re in a good place to apply what we’ve learned to our original goal – understanding how the randomness of a sample impacts the model design process.</p>
<p>In this lecture, we will delve more deeply into this idea of fitting a model to a sample. We’ll explore how to re-express our modeling process in terms of random variables and use this new understanding to steer model complexity.</p>
<section id="sample-statistics" class="level2">
<h2 class="anchored" data-anchor-id="sample-statistics">Sample Statistics</h2>
<p>In the last lecture, we talked at length about the concept of a distribution – a statement of all possible values that a random variable can take, as well as the probability of the variable taking on each value. Let’s take a moment to refine this definition.</p>
<ul>
<li>The distribution of a <em>population</em> describes how a random variable behaves across <em>all</em> individuals of interest.</li>
<li>The distribution of a <em>sample</em> describes how a random variable behaves in a specific sample from the population.</li>
</ul>
<p>In data science, we seldom have access to the entire population we wish to investigate. If we want to understand the distribution of a random variable across the population, we often need to use the distribution of collected samples to <em>infer</em> the properties of the population. For example, say we wish to understand the distribution of heights of people across the US population. We can’t directly survey every single person in the country, so we might instead take smaller samples of heights and use these samples to estimate the population’s distribution.</p>
<p>A common situation is wishing to know the mean of a population (eg the average height of all people in the US). In this case, we can take several samples of size <span class="math inline">\(n\)</span> from the population, and compute the mean of each <em>sample</em>.</p>
<p>In <a href="https://inferentialthinking.com/chapters/14/4/Central_Limit_Theorem.html?">Data 8</a>, you encountered the <strong>Central Limit Theorem (CLT)</strong>. This is a powerful theorem for estimating the distribution of a population with mean <span class="math inline">\(\mu\)</span> and standard deviation <span class="math inline">\(\sigma\)</span> from a collection of smaller samples. The CLT tells us that if an IID sample of size <span class="math inline">\(n\)</span> is large, then the probability distribution of the sample mean is <strong>roughly normal with mean</strong> <span class="math inline">\(\mu\)</span> and <strong>SD</strong> <span class="math inline">\(\sigma/\sqrt{n}\)</span>. In simpler terms, this means:</p>
<ul>
<li>Draw a sample of size <span class="math inline">\(n\)</span> from the population</li>
<li>Compute the mean of this sample; call it <span class="math inline">\(\bar{X}_n\)</span></li>
<li>Repeat this process: draw many more samples and compute the mean of each</li>
<li>The distribution of these sample means is normal with standard deviation <span class="math inline">\(\sigma/\sqrt{n}\)</span> and mean equal to the population mean, <span class="math inline">\(\mu\)</span></li>
</ul>
<p><img src="images/clt.png" alt="clt" width="600"></p>
<p>Importantly, the CLT assumes that each observation in our samples is drawn IID from the distribution of the population. In addition, the CLT is accurate only when <span class="math inline">\(n\)</span> is “large.” What counts as a “large” sample size depends on the specific distribution. If a population is highly symmetric and unimodal, we could need as few as <span class="math inline">\(n=20\)</span>; if a population is very skewed, we need a larger <span class="math inline">\(n\)</span>. Classes like Data 140 investigate this idea in great detail.</p>
<p>Why is this helpful? Consider what might happen if we estimated the population distribution from just <em>one</em> sample. If we happened, by random chance, to draw a sample with a different mean or spread than that of the population, we might get a skewed view of how the population behaves (consider the extreme case where we happen to sample the exact same value <span class="math inline">\(n\)</span> times!). By drawing many samples, we can consider how the sample distribution varies across multiple subsets of the data. This allows us to approximate the properties of the population without the need to survey every single member.</p>
<p>Notice the difference in variation between the two distributions that are different in sample size. The distribution with bigger sample size (<span class="math inline">\(n=800\)</span>) is tighter around the mean than the distribution with smaller sample size (<span class="math inline">\(n=200\)</span>). Try plugging in these values into the standard deviation equation for the normal distribution to make sense of this!</p>
</section>
<section id="prediction-and-inference" class="level2">
<h2 class="anchored" data-anchor-id="prediction-and-inference">Prediction and Inference</h2>
<p>At this point in the course, we’ve spent a great deal of time working with models. When we first introduced the idea of modeling a few weeks ago, we did so in the context of <strong>prediction</strong>: using models to make predictions about unseen data.</p>
<p>Another reason we might build models is to better understand complex phenomena in the world around us. <strong>Inference</strong> is the task of using a model to infer the true underlying relationships between the feature and response variables. If we are working with a set of housing data, <em>prediction</em> might ask: given the attributes of a house, how much is it worth? <em>Inference</em> might ask: how much does having a local park impact the value of a house?</p>
<p>A major goal of inference is to draw conclusions about the full population of data, given only a random sample. To do this, we aim to estimate the value of a <strong>parameter</strong>, which is a numerical function of the <em>population</em> (for example, the population mean <span class="math inline">\(\mu\)</span>). We use a collected sample to construct a <strong>statistic</strong>, which is a numerical function of the random <em>sample</em> (for example, the sample mean <span class="math inline">\(\bar{X}_n\)</span>). It’s helpful to think “p” for “parameter” and “population,” and “s” for “sample” and “statistic.”</p>
<p>Since the sample represents a random subset of the population, any statistic we generate will likely deviate from the true population parameter. We say that the sample statistic is an <strong>estimator</strong> of the true population parameter. Notationally, the population parameter is typically called <span class="math inline">\(\theta\)</span>, while its estimator is denoted by <span class="math inline">\(\hat{\theta}\)</span>.</p>
<p>To address our inference question, we aim to construct estimators that closely estimate the value of the population parameter. We evaluate how “good” an estimator is by answering three questions:</p>
<ul>
<li>Do we get the right answer for the parameter, on average?</li>
<li>How variable is the answer?</li>
<li>How close is our answer to the parameter?</li>
</ul>
<p>The <strong>bias</strong> of an estimator is how far off it is from the parameter, on average.</p>
<p><span class="math display">\[\text{Bias}(\hat{\theta}) = \mathbb{E}[\hat{\theta} - \theta] = \mathbb{E}[\hat{\theta}] - \theta\]</span></p>
<p>For example, the bias of the sample mean as an estimator of the population mean is:</p>
<p><span class="math display">\[\begin{align}\mathbb{E}[\bar{X}_n - \mu]
&amp;= \mathbb{E}[\frac{1}{n}\sum_{i=1}^n (X_i)] - \mu \\
&amp;= \frac{1}{n}\sum_{i=1}^n \mathbb{E}[X_i] - \mu \\
&amp;= \frac{1}{n} (n\mu) - \mu \\
&amp;= 0\end{align}\]</span></p>
<p>Because its bias is equal to 0, the sample mean is said to be an <strong>unbiased</strong> estimator of the population mean.</p>
<p>The <strong>variance</strong> of an estimator is a measure of how much the estimator tends to vary from its mean value.</p>
<p><span class="math display">\[\text{Var}(\hat{\theta}) = \mathbb{E}\left[(\hat{\theta} - \mathbb{E}[\hat{\theta}])^2 \right]\]</span></p>
</section>
<section id="modeling-as-estimation" class="level2">
<h2 class="anchored" data-anchor-id="modeling-as-estimation">Modeling as Estimation</h2>
<p>Now that we’ve established the idea of an estimator, let’s see how we can apply this learning to the modeling process. To do so, we’ll take a moment to formalize our data collection and models in the language of random variables.</p>
<p>Say we are working with an input variable, <span class="math inline">\(x\)</span>, and a response variable, <span class="math inline">\(Y\)</span>. We assume that <span class="math inline">\(Y\)</span> and <span class="math inline">\(x\)</span> are linked by some relationship <span class="math inline">\(g\)</span> – in other words, <span class="math inline">\(Y = g(x)\)</span>. <span class="math inline">\(g\)</span> represents some “universal truth” or “law of nature” that defines the underlying relationship between <span class="math inline">\(x\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p>As data scientists, we have no way of directly “seeing” the underlying relationship <span class="math inline">\(g\)</span>. The best we can do is collect observed data out in the real world to try to understand this relationship. Unfortunately, the data collection process will always have some inherent error (think of the randomness you might encounter when taking measurements in a scientific experiment). We say that each observation comes with some random error or <strong>noise</strong> term, <span class="math inline">\(\epsilon\)</span>. This error is assumed to be a random variable with expectation 0, variance <span class="math inline">\(\sigma^2\)</span>, and be IID across each observation. The existence of this random noise means that our observations, <span class="math inline">\(Y(x)\)</span>, are <em>random variables</em>.</p>
<p><span class="math display">\[\text{True relationship: }Y = g(x)\]</span></p>
<p><span class="math display">\[\text{Observed relationship: }Y = g(x) + \epsilon\]</span></p>
<p><img src="images/data.png" alt="data" width="600"></p>
<p>We can only observe our random sample of data, represented by the blue points above. From this sample, we want to estimate the true relationship <span class="math inline">\(g\)</span>. We do this by constructing the model <span class="math inline">\(\hat{Y}(x)\)</span> to estimate <span class="math inline">\(g\)</span>.</p>
<p><img src="images/y_hat.png" alt="y_hat" width="600"></p>
<p>If we assume that the true relationship <span class="math inline">\(g\)</span> is linear, we can re-express this goal in a slightly different way. The observed data is generated by the relationship:</p>
<p><span class="math display">\[Y(x) = g(x) + \epsilon = \theta_0 + \theta_1 x_1 + \ldots + \theta_p x_p + \epsilon\]</span></p>
<p>We aim to train a model to obtain estimates for each <span class="math inline">\(\theta_i\)</span>, which we refer to as <span class="math inline">\(\hat{\theta}_i\)</span>. Because <span class="math inline">\(\hat{Y}\)</span> is a fit to random data, we say that it is also a random variable.</p>
<p><span class="math display">\[\hat{Y}(x) = \hat{\theta}_0 + \hat{\theta}_1 x_1 + \ldots + \hat{\theta}_p x_p\]</span></p>
<p>Notice that <span class="math inline">\(Y\)</span> is dependent on <span class="math inline">\(\epsilon\)</span>, which means that <span class="math inline">\(Y\)</span> is a random variable itself. Additionally, the parameters of our model, <span class="math inline">\(\hat{Y}\)</span>, is also dependent on this randomnness, which means our predictor is random itself.</p>
</section>
<section id="the-bias-variance-trade-off" class="level2">
<h2 class="anchored" data-anchor-id="the-bias-variance-trade-off">The Bias Variance Trade-off</h2>
<p>Once we view our data and estimators as random variables, the process of how finding which models provide us with the best long run behaviors becomes more clear. Using concepts such as expectation and variances of the aforementioned random variables allows us to create theory for predicting the performance of models that works independently of the samples we actually collect. In this section, we will breakdown how this knowledge is summarized into 4 simple words: bias-variance trade-off.</p>
<p><img src="images/bvt.png" width="500"></p>
<section id="model-risk" class="level3">
<h3 class="anchored" data-anchor-id="model-risk">Model Risk</h3>
<p>First, we must define formulate our previous notions of training error and testing error into the form of a random variable. This parameter is called the <em>model risk</em>. This is the expectation of our prediction errors, the difference between the true <span class="math inline">\(Y\)</span> value and our predicted <span class="math inline">\(Y\)</span> value, over all possible samples at any fixed <span class="math inline">\(x\)</span>.</p>
<p><em>model risk</em> = <span class="math inline">\(\mathbb{E}[(Y-\hat{Y}(x))^2]\)</span></p>
</section>
<section id="the-three-components-of-model-risk" class="level3">
<h3 class="anchored" data-anchor-id="the-three-components-of-model-risk">The Three Components of Model Risk</h3>
<p>There are three types of errors that contribute to <em>model risk</em>: observation variance, bias, and model variance. The proof for the breakdown is out of scope, but understanding what this relationship tells us is crucial.</p>
<ol type="1">
<li><p>Observation Variance(<span class="math inline">\(\sigma^2\)</span>): irreducible random noise from the variability of <span class="math inline">\(\epsilon \sim N(0,\sigma^2)\)</span> term in Y.</p></li>
<li><p>Bias(<span class="math inline">\(g(x) - \hat{Y}(x)\)</span>): the difference between our model and the underlying function g.</p></li>
<li><p>Model Variance(<span class="math inline">\(E[(\hat{Y}(x) - E[\hat{Y}(x)])^2]\)</span>): the variability of our due to the randomness of the sample X’s.</p></li>
</ol>
<p>$[(Y-(x))^2] = + ^2 + $</p>
<p><img src="images/decomposition.png" width="500"></p>
</section>
<section id="observation-variance" class="level3">
<h3 class="anchored" data-anchor-id="observation-variance">Observation Variance</h3>
<p>The source of observation variance is the assumed random noise in our data, Y. As a part of the model, we can not perfectly control the data we observe: it is what it is. We call it irreducible for this reason.</p>
<p>Sources:</p>
<ul>
<li>measurement error</li>
<li>missing information</li>
</ul>
<p>Remedies:</p>
<ul>
<li>Out of scope</li>
</ul>
</section>
<section id="bias" class="level3">
<h3 class="anchored" data-anchor-id="bias">Bias</h3>
<p>The underlying true relationship g(x) is unknowable. The model bias is the difference between our model, the approximation of g(x), and the truth across all possible samples at an <span class="math inline">\(x\)</span>. In short, bias is an average measure for a <em>specific point</em> x. This most commonly comes from making over-simplifications.</p>
<p>Source:</p>
<ul>
<li>Underfitting</li>
<li>False assumption about the relationship between X and Y</li>
</ul>
<p>Remedies:</p>
<ul>
<li>Consult experts to ensure all relevant features are in the model.</li>
</ul>
<p><img src="images/bias.png" width="500"></p>
</section>
<section id="model-variance" class="level3">
<h3 class="anchored" data-anchor-id="model-variance">Model Variance</h3>
<p>Since the fitted model is based on a random sample, then, <em>if the sample came out differently</em>, we would have a different model. This variability across samples is our model variance.</p>
<p>Sources:</p>
<ul>
<li>Overfitting</li>
<li>High model complexity that makes the model sensitive to changes in the data.</li>
</ul>
<p>Remedies:</p>
<ul>
<li>Reduce model complexity</li>
</ul>
<p><img src="images/variance1.png" width="500"></p>
<p><img src="images/variance2.png" width="500"></p>
</section>
<section id="putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-it-all-together">Putting it all together</h3>
<p><span class="math inline">\(\mathbb{E}[(Y-\hat{Y}(x))^2] = \sigma^2 + (E[\hat{Y}(x)] - g(x))^2 + Var(\hat{Y}(x))\)</span></p>
<p>Notes:</p>
<ul>
<li>Model risk is an expectation and is therefore a fixed number (for a given x and model <span class="math inline">\(\hat{Y}(x)\)</span>).</li>
<li>Observation variance is irreducible.</li>
<li>As models increase in complexity, they often <strong>overfit</strong> the sample data and will have higher model variance. This often corresponds to a decrease in bias.</li>
<li>As models decrease in complexity, they often <strong>underfit</strong> the sample data and have lower model variance. This corresponds to an increase in bias.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>